import asyncio
import json
from pathlib import Path
from openai import AsyncOpenAI

# ==========================================
# CONFIG
# ==========================================
MODEL = "gpt-4.1"     # You can use gpt-5.1 if you want max quality
OUTPUT_DIR = Path("fundamentals")
INPUT_DIR = Path("fundamentals_input")

# ==========================================
# HELPER: build prompt for a single fundamental
# ==========================================
def build_prompt(meta: dict) -> str:
    """
    Build a prompt that generates a compact, high-quality Python template file
    with a structured ASCII metadata header and a concise LeetCode-style problem description.
    """
    return f'''
Generate a SINGLE Python file containing a coding problem template.

Follow these rules STRICTLY:

============================================================
1. HEADER FORMAT (USE THIS EXACT ASCII STYLE)
============================================================

# [ Name: {meta['name']} ]  [ Category: {meta['category']} ]  [ Topic: {meta['topic']} ]  [ Weight: {meta['weight']} ]

============================================================
2. PROBLEM DESCRIPTION (CONCISE)
============================================================

Write a short and clear problem description in a triple-quoted string.
Rules for the description:

- MUST resemble a typical LeetCode prompt
- 3 to 8 lines maximum
- Describe:
    - the goal of the problem
    - the inputs (briefly)
    - expected output
    - edge cases or constraints (short!)
- One small example allowed
- NO solution strategies
- NO pseudocode
- NO unnecessary paragraphs

============================================================
3. IMPLEMENTATION SKELETON
============================================================

After the description:

- Write the EXACT function signature:
      {meta['signature']}

- Inside the body, place ONLY (no extra comments or implementation or CODE):
      pass
      
- Add necessary imports (e.g., List, Optional) if the signature requires them.

============================================================
4. TEST CASES (GENERATED BY YOU)
============================================================

At the bottom of the same file:

if __name__ == "__main__":
    # Generate at least 8 assert-based tests (no new line between them)
    # Based on the description and your understanding of the problem
    # Make the tests meaningful and correct

============================================================
5. OUTPUT
============================================================

- Output ONLY valid Python code.
- Do NOT include markdown.
- Do NOT include backticks.

============================================================
6. EXAMPLE OUTPUT
============================================================

# [ Name: Two Pointers â€” Palindrome Check ]  [ Category: arrays ]  [ Topic: two_pointers ]  [ Weight: 9 ]

"""
Problem Description:
Given a list of integers, determine if it is a palindrome.
A palindrome is a sequence that reads the same forwards and backwards.
Return True if the sequence is a palindrome, otherwise return False.

Constraints:
- Input: list of integers (0 <= len(nums) <= 10^5)
- An empty list counts as a palindrome.

Example:
Input: [3, 4, 5, 4, 3] -> Output: True
"""

from typing import List


def is_palindrome(nums: List[int]) -> bool:
    pass


if __name__ == "__main__":
    assert is_palindrome([1, 2, 3, 2, 1]) == True
    assert is_palindrome([1, 2, 3, 4, 5]) == False
    assert is_palindrome([]) == True
    assert is_palindrome([9]) == True
    assert is_palindrome([7, 8, 8, 7]) == True
    assert is_palindrome([1, 0, 1, 0]) == False
    assert is_palindrome([5, 6, 5]) == True
    assert is_palindrome([1, 2, 2, 3]) == False

    print("All tests passed.")

'''

# ==========================================
# MAIN GENERATION
# ==========================================
def iter_fundamentals_from_dir():
    """
    Iterate over all JSON files in fundamentals_input, yielding (group_name, items).

    Supported JSON shapes:
    - Array at top-level: uses the filename (stem) as group name.
    - Object with key "fundamentals": uses filename as group name for that list.
    - Object with other list-valued keys: uses each key as the group name.
    """
    for json_file in sorted(INPUT_DIR.glob("*.json")):
        with open(json_file, "r") as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError as exc:
                print(f"[!] Skipping {json_file}: invalid JSON ({exc})")
                continue

        # Case 1: top-level array -> use filename as group
        if isinstance(data, list):
            yield json_file.stem, data
            continue

        if not isinstance(data, dict):
            print(f"[!] Skipping {json_file}: expected an object or array at top-level")
            continue

        yielded = False

        # Case 2: explicit "fundamentals" key -> use filename as group
        fundamentals_list = data.get("fundamentals")
        if isinstance(fundamentals_list, list):
            yield json_file.stem, fundamentals_list
            yielded = True

        # Case 3: other list-valued keys -> use the key as the group
        for group_name, group_items in data.items():
            if group_name in {"fundamentals", "meta"}:
                continue
            if not isinstance(group_items, list):
                print(f"[!] Skipping group '{group_name}' in {json_file}: expected a list")
                continue
            yield group_name, group_items
            yielded = True

        if not yielded:
            print(f"[!] Skipping {json_file}: no list-valued groups found")


def generate_all_fundamentals():
    async def generate_one(client: AsyncOpenAI, semaphore: asyncio.Semaphore, group_dir: Path, width: int, idx: int, meta: dict):
        prompt = build_prompt(meta)
        print(f"[*] Generating: {meta['id']}  ({group_dir.name})")

        async with semaphore:
            response = await client.responses.create(
                model=MODEL,
                input=prompt
            )

        content = response.output_text

        file_name = f"{idx:0{width}d}_{meta['id']}.py"
        file_path = group_dir / file_name
        await asyncio.to_thread(file_path.write_text, content)
        print(f"[+] Saved to {file_path}")

    async def process_group(client: AsyncOpenAI, semaphore: asyncio.Semaphore, group_name: str, group_items: list):
        group_dir = OUTPUT_DIR / group_name
        group_dir.mkdir(parents=True, exist_ok=True)

        # zero-pad filenames based on group size; at least 2 digits, grows if needed
        width = max(2, len(str(len(group_items) - 1)))

        tasks = [
            asyncio.create_task(generate_one(client, semaphore, group_dir, width, idx, meta))
            for idx, meta in enumerate(group_items)
        ]
        await asyncio.gather(*tasks)

    async def run():
        client = AsyncOpenAI()
        semaphore = asyncio.Semaphore(5)  # limit concurrent API calls

        for group_name, group_items in iter_fundamentals_from_dir():
            await process_group(client, semaphore, group_name, group_items)
        print("All fundamentals generated successfully.")

    asyncio.run(run())


if __name__ == "__main__":
    generate_all_fundamentals()
